<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Extjs 4 on All the things about web and javascript</title>
    <link>http://vadimpopa.com/categories/extjs-4/</link>
    <description>Recent content in Extjs 4 on All the things about web and javascript</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>Copyright (c) 2008 - 2014, Vadim Popa; all rights reserved.</copyright>
    <lastBuildDate>Sun, 02 Mar 2014 21:12:06 +0300</lastBuildDate>
    <atom:link href="http://vadimpopa.com/categories/extjs-4/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Split large AngularJS Controllers using the Mixin Pattern</title>
      <link>http://vadimpopa.com/split-large-angularjs-controllers-using-the-mixin-pattern/</link>
      <pubDate>Sun, 02 Mar 2014 21:12:06 +0300</pubDate>
      
      <guid>http://vadimpopa.com/split-large-angularjs-controllers-using-the-mixin-pattern/</guid>
      <description>&lt;p&gt;In case if your controller became too large and the inheritance is not a solution, the Mixin pattern can solve this problem very easy by splitting the logic in mixins each serving a functionality or a feature. Within AngularJS I found a easy to do it by using the &lt;code&gt;$controller&lt;/code&gt; service.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;//AngularJS Mixin
app.controller(&#39;CanSingController&#39;, [&#39;$scope&#39;
    function ($scope) {
    	$scope.sing = function() {
	         alert(&amp;quot;I&#39;m on the highway to hell...&amp;quot;)
	    };
    }
]);


app.controller(&#39;MusicianController&#39;, [&#39;$scope&#39;
    function ($scope) {
    	var canSingCtrl = $controller(&#39;CanSingController&#39;,{$scope: $scope});

    	$scope.whatMusicianCanDo = function() {

    		//Call locally, or best call sing in your view
    		$scope.sing();
    	};
    }
]);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;For fun and comparation I brought also an ExtJS example found in its &lt;a href=&#34;http://docs.sencha.com/extjs/4.2.2/#!/api/Ext.Class-cfg-mixins&#34; title=&#34;http://docs.sencha.com/extjs/4.2.2/#!/api/Ext.Class-cfg-mixins&#34;&gt;documentation&lt;/a&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;//ExtJS Mixin
Ext.define(&#39;CanSing&#39;, {
     sing: function() {
         alert(&amp;quot;I&#39;m on the highway to hell...&amp;quot;)
     }
});

Ext.define(&#39;Musician&#39;, {
     mixins: [&#39;CanSing&#39;]
})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So the &lt;code&gt;Musician&lt;/code&gt; will get a &lt;code&gt;sing&lt;/code&gt; method from &lt;code&gt;CanSing&lt;/code&gt; &lt;code&gt;controller&lt;/code&gt;/&lt;code&gt;mixin&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;If to raise same issue from ExtJS&amp;rsquo;s documentation: &lt;em&gt;what if the Musician already has a sing method? Or you want to mix in two classes, both of which define sing?&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;In AngularJS this can be solved by defining the &lt;code&gt;sing&lt;/code&gt; method in the instantiated mixin, and use an identifier or a local variable within the parent controller to keep that instance:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;//AngularJS Mixin without overriding
app.controller(&#39;CanSingController&#39;, [&#39;$scope&#39;
    function ($scope) {

	    return {
	    	sing: function() {
		         alert(&amp;quot;I&#39;m on the highway to hell...&amp;quot;)
		    }
	    }
    }
]);

app.controller(&#39;MusicianController&#39;, [&#39;$scope&#39;
    function ($scope) {
    	var canSing = $controller(&#39;CanSingController as canSing&#39;,{$scope: $scope}),

    	$scope.sing = function() {

    		// call trough the local variable
    		canSing.sing();	

    		//call trough the indentifier
    		$scope.canSing.sing();
    	}
    }
]);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Usually I define within the &lt;code&gt;$scope&lt;/code&gt; the methods which are going to be exposed in views and in the instance the ones which will be called locally in the parent controller. This way I preserve a sort of encapsulation and also looks cleaner. But when defining wihtin the &lt;code&gt;$scope&lt;/code&gt; just make sure not to have overrides. To avoid them you could just use the &lt;code&gt;identifier&lt;/code&gt; approach which in some way also gives sort of encapsulation of all methods within one property.&lt;/p&gt;

&lt;p&gt;In ExtJS: &lt;em&gt;it&amp;rsquo;s good to define mixins as an object, where you assign a name to each mixin. In this case the sing method of &lt;code&gt;Musician&lt;/code&gt; will overwrite the mixed in &lt;code&gt;sing&lt;/code&gt; method. But you can access the original mixed in method through special mixins property.&lt;/em&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;//ExtJS Mixin without overriding
Ext.define(&#39;Musician&#39;, {
     mixins: {
         canSing: &#39;CanSing&#39;
     },

     sing: function() {
         // delegate singing operation to mixin
         this.mixins.canSing.sing.call(this);
     }
})
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>How to add SVG patterns in your ExtJS 4.2.1 apps</title>
      <link>http://vadimpopa.com/how-to-add-svg-patterns-in-your-extjs-4-2-1-apps/</link>
      <pubDate>Mon, 23 Sep 2013 21:12:06 +0300</pubDate>
      
      <guid>http://vadimpopa.com/how-to-add-svg-patterns-in-your-extjs-4-2-1-apps/</guid>
      <description>&lt;p&gt;&lt;img class=&#34;right&#34; src=&#34;../../images/svg-patterns-380x300.png&#34; style=&#34;display: block;margin: 0 auto; width:380;height:300;&#34;&gt;&lt;/p&gt;

&lt;p&gt;Though aren&amp;#8217;t widely used &lt;a title=&#34;http://www.w3.org/TR/SVG/pservers.html&#34; href=&#34;http://www.w3.org/TR/SVG/pservers.html&#34; target=&#34;_blank&#34;&gt;SVG Patterns&lt;/a&gt; are very powerful and light. Being vector graphics, a pattern adjusts very well to any screen resolution making the &lt;a title=&#34;http://philbit.com/svgpatterns/&#34; href=&#34;http://philbit.com/svgpatterns/&#34; target=&#34;_blank&#34;&gt;background crisp and nice&lt;/a&gt;. The only drawback would be is the lack of support on IE8 and lower and yes the lack of support in ExtJS 4.2.1 (and lower) too.&lt;/p&gt;

&lt;p&gt;Hopefully next versions of ExtJS will have within its SVG engine the needed piece which would allow us to add and use patterns in our ExtJS web apps. Until then, you can check a demo on this &lt;a title=&#34;https://fiddle.sencha.com/#fiddle/i9&#34; href=&#34;https://fiddle.sencha.com/#fiddle/i9&#34; target=&#34;_blank&#34;&gt;sencha fiddle&lt;/a&gt; to see how SVG patterns can be added and used along with &lt;a href=&#34;http://docs.sencha.com/extjs/4.2.1/#!/guide/drawing&#34; title=&#34;http://docs.sencha.com/extjs/4.2.1/#!/guide/drawing&#34;&gt;Ext.draw&lt;/a&gt; package. The demo shows a white background with &lt;a href=&#34;http://philbit.com/svgpatterns/#subtledots&#34; title=&#34;http://philbit.com/svgpatterns/#subtledots&#34;&gt;subtle dots&lt;/a&gt; in a chart and a circle sprite.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>How to add custom sprites in ExtJS charts</title>
      <link>http://vadimpopa.com/how-to-add-custom-sprites-in-extjs-charts/</link>
      <pubDate>Sat, 07 Sep 2013 17:50:16 +0300</pubDate>
      
      <guid>http://vadimpopa.com/how-to-add-custom-sprites-in-extjs-charts/</guid>
      <description>&lt;p&gt;Though ExtJS charts are very rich in features sometimes our clients want more. Very often they want some specific features which in the end leads to adding new custom sprites to the charts. And ExtJS is ready to help us with the needed tools to accomplish those features and make the client happy.&lt;/p&gt;

&lt;p&gt;In this post I&amp;#8217;m going to add some light on how to add custom sprites in ExtJS charts based on a real world example. Let&amp;#8217;s say that the client would need sort of threshold line which would outline a few areas on the chart.&lt;/p&gt;

&lt;p&gt;&lt;img class=&#34;right&#34; src=&#34;../../images/charts_thresholds.png&#34; style=&#34;display: block;margin: 0 auto; width:380px;height:300px;&#34;&gt;&lt;/p&gt;

&lt;p&gt;First thought which comes is how this feature would be integrated in our chart component, in a easy way that is usual for ExtJS and its users. Right, first we would need some chart configs, something like these ones below, or even could be an array of them:&lt;/p&gt;

&lt;!-- more --&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;{
    threshold: 36,
    title: &#39;Goal&#39;
 }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Luckily we can benefit of ExtJS&amp;#8217;s tools like plugins, mixins, extensions and drawing classes. Assuming that you know already the difference between a mixin and a plugin, I&amp;#8217;ll answer to the question which we brought earlier that for integration we would need a plugin.&lt;/p&gt;

&lt;p&gt;Now we can wrap those configs in a plugin config, in a chart component:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;Ext.create(&#39;Ext.chart.Chart&#39;, {
        plugins: [{
            ptype: &#39;chartthresholds&#39;,
            items: [{
                  threshold: 36,
                  title: &#39;Goal&#39;
            },{
                threshold: 66,
                title: &#39;Huge&#39;
            }]
        }]
    });
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Having already the definition of the task, now we can define our plugin:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;Ext.define(&#39;Ux.chart.Thresholds&#39;, {
    extend: &#39;Ext.AbstractPlugin&#39;,
    alias: &amp;quot;plugin.chartthresholds&amp;quot;,
    constructor: function(config) {
      var me = this;

      // The collections of threshold items
      me.items = [];

      if (config) {
          Ext.apply(me, config);
      }
    },
     /**
     * The plugin initialization method which the owning Component calls at Component initialization time.
     */
    init : function(chart){}

    /**
     * The plugin cleanup method which the owning Component calls at Component destruction time.
     */
    destroy : function() {}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As you see from task definition we can have more threshold items, so our plugin will have a second purpose, which is, to act as a collection of threshold items.&lt;/p&gt;

&lt;p&gt;Now as we have the collection class prototyped we need the item, a ExtJS tool to use for to display on the chart a line and a text. Always look the answer in ExtJS source code in the respective classes. Since we are working with charts and drawing we can get the answer in a snap by looking for example how Legend is created, that we need to use Sprites to draw both the line and the text and a CompositeSprite to wrap them.&lt;/p&gt;

&lt;p&gt;But why would we need a CompositeSprite ? as the docs say a composite Sprite handles a group of sprites with common methods to a sprite such as hide, show, setAttributes. These methods are applied to the set of sprites added to the group. I would add also to importance the destroy method.&lt;/p&gt;

&lt;p&gt;Our threshold item gets the following definition:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;Ext.define(&#39;Ux.chart.ThresholdItem&#39;, {
        extend: &#39;Ext.draw.CompositeSprite&#39;,

        visible: false,

        constructor: function(config) {
            var me = this;

            if (config) {
                Ext.apply(me, config);
            }

            me.callParent();

            me.on(&#39;mousedown&#39;, me.onMouseDown, me);
        },

        /**
         * @private Handler for threshold selecting/deselecting
         */
        onMouseDown: function() {
        }
    });
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Next will finish our prototyping with adding methods definitions to the plugin for both sprites, the line and text:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;Ext.define(&#39;Ux.chart.Thresholds&#39;, {
    extend: &#39;Ext.AbstractPlugin&#39;,

    .....................

   /**
    * @private Redraws all items, called after each chart redraw
    */
    redraw: function(){},

    /**
     * @private Draws threshold items
     */
     drawItems: function(){},

    /**
     * @private Creates label sprite and/or redraws it to the given position
     */
    drawLabel: function(item,x,y,z) {},

    /**
     * @private Creates line sprite and/or redraws it to the given position
     */
    drawLine: function(item,fromX, fromY, toX, toY, z) {
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Once we are done with prototyping we can proceed to sprites drawing.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;drawLine: function(item,fromX, fromY, toX, toY, z) {
            var line = item.get(&#39;line&#39;),
                path = &#39;M&#39; + fromX + &#39;,&#39; + fromY + &#39;L&#39; + toX + &#39;,&#39; + toY;

            if(line){
                line.setAttributes({ path : path},true);
            }else{
                line = item.add(&#39;line&#39;, item.surface.add({
                    type: &#39;path&#39;,
                    path: path,
                    zIndex: z,
                    &amp;quot;stroke-width&amp;quot;: this.lineWidth,
                    opacity: 0,
                    fill: &#39;#a0142c&#39;,
                    stroke: this.lineStroke,
                    style: {
                        cursor: &#39;pointer&#39;
                    }
                }));
            }

            return line;
        },
        drawLabel: function(item,x,y,z) {
            var label = item.get(&#39;label&#39;);

            if(label){
                label.setAttributes({ x:x, y:y },true);
            }else{
                label = item.add(&#39;label&#39;, item.surface.add({
                    type: &#39;text&#39;,
                    x: x,
                    y: y,
                    zIndex: z,
                    fill: this.labelColor,
                    font: this.labelFont,
                    text: item.title,
                    style: {
                        cursor: &#39;pointer&#39;
                    }
                }));
            }
            return label;
        }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Drawing methods are ready, it&amp;#8217;s time to get their coordinates. The coordinates are relative to design specifications, what&amp;#8217;s important is to get the idea on how to get them and how to use. Once you understand this you can play with positioning according to your designs. Below method it&amp;#8217;s what you would need to get started with the game.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;drawItems: function(){
            var me = this,
                chart = me.cmp,
                axes = chart.axes,
                leftAxis = axes.get(&#39;left&#39;),
                stepHeight = leftAxis.length / (leftAxis.to - leftAxis.from),
                x2 = leftAxis.width + leftAxis.x,
                zIndex = (this.zIndex || 0) + 2,
                items = me.items,
                li = items.length,
                i = 0,
                y1,item;

            for (; i &amp;amp;lt; li; i++) {
                item = items[i];

                y1 = leftAxis.y - stepHeight * item.threshold;

                me.drawLabel(item,5,y1, zIndex + 1);
                me.drawLine(item,5,y1-1,x2,y1-1,zIndex);

                if(!item.visible){
                    item.setAttributes({
                        hidden: false
                    }, true);

                    item.visible = true;
                }
            }
        }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It&amp;#8217;s time to instantiate the items:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;createItems: function() {
            var me = this,
                surface = me.cmp.surface,
                items = me.items,
                li = items.length,
                i = 0,
                item;

            for (; i &amp;amp;lt; li; i++) {
                item[i] = Ext.create(&#39;Ux.chart.ThresholdItem&#39;,Ext.apply({
                    thresholds: me,
                    surface: surface
                },items[i]));
            }
        }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then finally redraw and init the plugin:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;init: function (chart) {
            this.labelColor = chart.textColor;

            if(this.visible)
                Ext.Function.interceptAfter(chart,&amp;quot;redraw&amp;quot;,this.redraw,this);
        },
        redraw: function() {
            var me = this;

            if (!me.created) {
                me.created = true;
                me.createItems();
            }

            if(me.visible)
                me.drawItems();
        }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Notice that the visible config, you could add a few lines of code to add some laziness and to make the threshold item visible later but not at first chart redraw.&lt;/p&gt;

&lt;p&gt;And yes, we end with cleaning:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;destroy: function(){
            var items = this.items,
                li = items.length,
                i = 0;
            
            for (; i &amp;amp;lt; li; i++) {
                items[i].destroy();
            }
        }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That&amp;#8217;s it, have a enjoyable charts customizing process.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Inside Aymap, an ExtJS4 web application, part 2</title>
      <link>http://vadimpopa.com/aymap-part-2/</link>
      <pubDate>Tue, 02 Apr 2013 22:59:32 +0300</pubDate>
      
      <guid>http://vadimpopa.com/aymap-part-2/</guid>
      <description>&lt;p&gt;In this post will continue Aymap views exploration and share with you some extension tips and tricks that I&amp;#8217;ve used and I think might be useful for you too in writing your ExtJS4 web application.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;AyToolbox&lt;/em&gt;&lt;/strong&gt;&lt;br /&gt;
If to look in previous part at &lt;code&gt;AyToolbox&lt;/code&gt; you can see that contains 5 items of &lt;code&gt;toolboxpanel&lt;/code&gt; &lt;code&gt;xtype&lt;/code&gt;. This widget does the job for 5 views and has the following define:&lt;/p&gt;

&lt;!-- more --&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;Ext.define(&#39;AyMap.view.toolbox.Panel&#39;,{
    extend : &#39;Ext.grid.Panel&#39;,

   // More configs
    initComponent: function(){
        var me = this,
            store;

        Ext.apply(me,{
            // More configs
            columns: [{
                width: 100,
                sortable: true,
                dataIndex: &#39;name&#39;
            }],
                listeners: {
                    afterrender: function(view){
                        view.getPlugin(&#39;gridviewdragdrop&#39;).dragZone.getDragText = function() {
                            return this.dragData.records[0].get(&#39;name&#39;)
                        }

                        Ext.create(&#39;Ext.tip.ToolTip&#39;, {
                            target: view.el,
                            delegate: view.itemSelector,
                            trackMouse: true,
                            renderTo: Ext.getBody(),
                            listeners: {
                                beforeshow: function(tip) {
                                    tip.update(this.getRecord(tip.triggerElement).get(&#39;name&#39;));
                                },
                                scope: view
                            }
                        });
                    }
                }
            }
        });
        me.callParent(arguments);
        store = me.getStore();
        store.guaranteeRange(0, store.pageSize-1);
    }
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note the best approach on how to add tooltips to grid columns trough delegation, which is much performant than using renderers:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;renderers:  function (value, metadata){
        metadata.tdAttr = &#39;data-qtip=&amp;quot; &#39; + value + &#39;&amp;quot;&#39;;
        return value;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;While working on this class I&amp;#8217;ve learned that if to use ExtJS Models at maximum, you can simplify views configurations. If you have a few similar views, like I had in &lt;em&gt;AyToolbox&lt;/em&gt;, but your columns &lt;em&gt;dataIndexes&lt;/em&gt; are not the same tough have the same goal: to show a description, &lt;strong&gt;then use Model&amp;#8217;s mapping feature&lt;/strong&gt;. Below you can see how mapping is done for a few models which are bound to the stores that provide records to those 5 grids within &lt;code&gt;AyToolbox&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;Ext.define(&#39;AyMap.model.Output&#39;, {
    extend: &#39;Ext.data.Model&#39;,
    fields: [
        {name: &#39;name&#39;, mapping: &#39;output_name&#39;,  type: &#39;string&#39;}

    ]
});

Ext.define(&#39;AyMap.model.Camera&#39;, {
    extend: &#39;Ext.data.Model&#39;,
    fields: [
    	{name: &#39;name&#39;, mapping: &#39;resource_name&#39;,  type: &#39;string&#39;}
    ]
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;Aymap objects&lt;/em&gt;&lt;/strong&gt;&lt;br /&gt;
{% img right ../images/posts/map.png 260 180 %}&lt;/p&gt;

&lt;p&gt;If you look at an Aylook map(see left image), you can see some white or transparent fancy boxes. Those are aylook objects, each one having a few common styling properties like: colors, transparency, icons, borders; and a few Aylook specific properties: data related to the surveillance system and its devices. &lt;strong&gt;Under those objects actually stands the powerful ExtJS &lt;code&gt;Ext.Component&lt;/code&gt; and the magic of &lt;code&gt;Ext.XTemplate&lt;/code&gt;&lt;/strong&gt;. Using these nice classes, was easy enough just implement basics object layout/template, define an AbstractObject which covers objects common properties and functionalities and then extended it to get all types of objects Aylook would have &amp;#8211; mission accomplished.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;Ext.define(&#39;AyMap.ux.AbstractObject&#39;, {
    extend: &#39;Ext.Component&#39;,
    //More configs
    createObjTemplate: function(){
      return  new Ext.XTemplate(
        //Objects template
      );
    }
});

Ext.define(&#39;AyMap.ux.object.Camera&#39;, {
    extend: &#39;AyMap.ux.AbstractObject&#39;,
    //More specific configs
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Another trick I&amp;#8217;ve used here is a factory class with a method which actually simplifies objects creation and decouples objects related code from UI code.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;Ext.define(&#39;AyMap.util.ObjectFactory&#39;, {
    requires: [
        &#39;AyMap.ux.object.Camera&#39;,
        &#39;AyMap.ux.object.Zone&#39;
         //More requires
    ],

    singleton: true,

    create: function (type, config, extraData) {
        var object;
        switch (type) {
            case &#39;camera&#39;: {
               // Process configs here, make some changes...then create the object
               object = Ext.create(&#39;AyMap.ux.object.Camera&#39;, config);
            }
            //More objects
        return object;
    }
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;Properties windows&lt;/em&gt;&lt;/strong&gt;&lt;br /&gt;
One of the main functionality of the Aymap is to change those objects properties according to user&amp;#8217;s preferences. This is done by a few properties windows which also have some common functionality. When building ExtJS applications you often might have common functionalities, which means that you have to use inheritance &amp;#8211; one of the base core feature provided by ExtJS.The same principle was used here. As you can see in images, all windows have in common the colours fieldset and the positions fields, which means that their code can be wrapped in methods that belong to the parent class:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;Ext.define(&#39;AyMap.view.Properties&#39;, {
    extend: &#39;Ext.window.Window&#39;

    //Add window configs, example:
    modal: true,
    resizable: false,
    layout: &#39;fit&#39;,
    width: 300,

    initComponent: function () {
        var me = this;

        Ext.apply(me, {
            title : &#39;Objects properties&#39;
            // Add common configs
        });
        me.callParent();

        //Add common events, for all windows
        me.on(&#39;beforeclose&#39;, me.onBeforeClose,this);
        me.down(&#39;form&#39;).on(&#39;dirtychange&#39;,me.onFormDirtyChange);
    },
    getColoursFildsetCfg: function(){
        return {
            xtype: &#39;fieldset&#39;
            // more configs
        }
    },
    getPositionsFieldsCfg: function(){
        return {
            xtype: &#39;container&#39;,
            layout: &#39;column&#39;,
            defaultType: &#39;numberfield&#39;,
            defaults: {
                labelWidth: 15,
                minValue: 0,
                columnWidth: 0.50
            },
            items: [{
                fieldLabel: &#39;x&#39;,
                name: &#39;x&#39;
            },
            {
                fieldLabel: &#39;y&#39;,
                name: &#39;y&#39;
            }]
        };
    },
    getFormCfg: function(cfg){
        return Ext.apply(cfg,{
            xtype: &#39;form&#39;,
            frame: false,
            trackResetOnLoad: true,
            bodyPadding: 2,
            buttons: []
        });
    }
    // Add other methods and event handlers that are in common for all windows
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then, in the final class, you can customise form&amp;#8217;s items and add other specific code and configs:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;Ext.define(&#39;AyMap.view.properties.Camera&#39;, {
    extend: &#39;AyMap.view.Properties&#39;,

    initComponent: function () {
        var me = this;

        Ext.apply(me, {
            //Add other specific configs
            items: [me.getFormCfg({
                items: [
                    me.getImgOnFieldCfg(),
                    me.getPositionsFieldsCfg(),
                    me.getCheckboxesCfg(),
                    me.getColorFieldsCfg()
                ]
            })]
        });

        me.callParent();
    }
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;{% img ../images/posts/camera.png 260 180 %}
{% img ../images/posts/link.png 260 180 %}
{% img ../images/posts/panel.png 260 180 %}&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Conclusions&lt;/strong&gt;&lt;br /&gt;
All tips I&amp;#8217;ve shown you and all other you might come up with can make your code smaller and cleaner. Also by applying them we touched some of the applications quality attributes: performance, flexibility and maintainability. Personally, while writing these posts I&amp;#8217;ve learned a important rule that there&amp;#8217;s always place for optimisations. So, think at least twice to the code, before writing and after, if this is the best solution you come up with.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Reload a single record and refresh its ExtJs grid row</title>
      <link>http://vadimpopa.com/reload-a-single-record-and-refresh-its-extjs-grid-row/</link>
      <pubDate>Sat, 09 Mar 2013 17:50:16 +0300</pubDate>
      
      <guid>http://vadimpopa.com/reload-a-single-record-and-refresh-its-extjs-grid-row/</guid>
      <description>&lt;p&gt;Just gave the answer to this question on &lt;a title=&#34;extjs forum&#34; href=&#34;http://www.sencha.com/forum/showthread.php?258228-Reloading-a-single-record-droma-grid&#34; target=&#34;_blank&#34;&gt;extjs4 forum&lt;/a&gt; and decided to post it here too by adding a code example. The answer is very simple: just load the record with the new data from the server by using the static method &lt;code&gt;Ext.data.Model.load(id,config)&lt;/code&gt; then in the successful callback update that record, do a commit if you need, then refresh record&amp;#8217;s node. Below the explanation in code form:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;Ext.define(&#39;Writer.Person&#39;, {
    extend: &#39;Ext.data.Model&#39;,
    fields: [
        {name: &#39;id&#39;, type: &#39;int&#39;},
        {name: &#39;name&#39;, type: &#39;string&#39;}
    ],
    proxy {
      // Config for your proxy, it&#39;s a must for model to have a proxy.
    }
});

Writer.Person.load(3, {
    scope: grid,
    failure: function(record, operation) {
        //do something if the load failed
    },
    success: function(record, operation) {
        var store = grid.getStore(),
            recToUpdate = store.getById(3);

         recToUpdate.set(record.getData());

     // Do commit if you need: if the data from
     // the server differs from last commit data
         recordToUpdate.commit();

         grid.getView().refreshNode(store.indexOfId(3));
    },
    callback: function(record, operation) {
        //do something whether the load succeeded or failed
    }
});
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Inside Aymap, an ExtJS4 web application, part 1</title>
      <link>http://vadimpopa.com/aymap-part1/</link>
      <pubDate>Sat, 16 Feb 2013 22:59:32 +0300</pubDate>
      
      <guid>http://vadimpopa.com/aymap-part1/</guid>
      <description>&lt;p&gt;&lt;strong&gt;Overview&lt;/strong&gt;&lt;br /&gt;
Having more than two years of experience in developing web applications based on Sencha Products, I thought I would start this blog with the first article about an ExtJS4 based application. As on the internet you can find a lot of simple applications and thousands of examples and solutions on how to do ordinary things or how to achieve a behavior, articles about real life applications are a few.&lt;/p&gt;

&lt;p&gt;So these posts will cover how to build a real life application, from views to application structure and architecture, ending with application’s specifics. The app itself is called Aymap and takes care of drawing and customizing surveillance maps for a surveillance system called Aylook, which you can find more about on &lt;a title=&#34;www.aylook.com&#34; href=&#34;http://aylook.com&#34; target=&#34;_blank&#34;&gt;www.aylook.com&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;This articles require some ExtJS knowledge in order to understand the code, as I won&amp;#8217;t add explanations to it except to some parts which may need. So to understand them is necessary to know: ExtJS class system, ExtJS widgets, how to extend a component and the basics of an ExtJS app, thus almost everything what you find in &lt;a title=&#34;Sencha&#34; href=&#34;http://sencha.com&#34; target=&#34;_blank&#34;&gt;Sencha&lt;/a&gt;&amp;#8216;s guide from the ExtJS4 documentation link.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Intro&lt;/strong&gt;&lt;br /&gt;
When designing an application besides the functional requirements should be considered the quality attributes requirements too as they affect the run-time behavior, system design and the user experience. Performance, flexibility, maintainability, usability and conceptual integrity were the main attributes, for Aymap. ExtJS4 covers all of them in some level, which is one of the reasons why we chose it, but for a full cover, from developer side is needed a good JavaScript knowledge, best ExtJS practices and a solid application architecture.&lt;/p&gt;

&lt;p&gt;As is written in sencha guides splitting up the application’s UI into views is the first step of building an app, well of course except the cases when there are some challenging UI parts which you might first want to try to find their solutions, to be sure that the project is feasible, is just as I do usually. The splitting operation should result with a balance between the views, not too granular but at the same time no too generic.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;The Viewport&lt;/strong&gt;&lt;br /&gt;
For Aymap I’ve come up with a simple Viewport as you can see in the picture and code:&lt;br /&gt;
{% img center ../images/posts/aymap_viewport.png 580 400 %}&lt;/p&gt;

&lt;p&gt;``` javascript app/view/Viewport.js
Ext.define(&amp;lsquo;AyMap.view.Viewport&amp;rsquo;,{&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/* Begin Definitions */

extend : &#39;Ext.container.Viewport&#39;,

alias: &#39;widget.ayviewport&#39;,

requires: [
    &#39;Ext.layout.container.Border&#39;,
    &#39;Ext.ux.StatusBar&#39;
],

/* End Definitions */

layout: &#39;border&#39;,

/**
 * @property {Boolean} isFullscreen
 * Read-only property indicating whether the viewport is in fullscreen mode or not
 */

isFullscreen: false,

initComponent: function(){

    Ext.apply(this,{
        items: [{
                xtype: &#39;aymenu&#39;,
                itemId: &#39;menu&#39;,
                region: &#39;north&#39;
            },{
                xtype: &#39;aytoolbox&#39;,
                itemId: &#39;toolbox&#39;,
                region : &#39;west&#39;
            },{
                xtype: &#39;statusbar&#39;,
                itemId: &#39;statusbar&#39;,
                region: &#39;south&#39;,
                height:26,
                defaultText: localizer.get(&#39;statusBarDefaultText&#39;),
                statusAlign: &#39;right&#39;,
                items: [{
                    xtype: &#39;component&#39;,
                    itemId: &#39;cmpLeftStatus&#39;,
                    cls: &#39;ay-left-status&#39;,
                    tpl: &#39;&amp;amp;lt;span&amp;amp;gt;{text}&amp;amp;lt;/span&amp;amp;gt;&#39;
                }]
            },{
                xtype:&#39;mapcontainer&#39;,
                region: &#39;center&#39;
            }]
    });
    this.callParent(arguments);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;});&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
Aymap viewport is consisted from:

*   AyMenu `Ext.toolbar.Toolbar` - menu which covers all Aymap operations on aylook maps
*   AyToolbox `Ext.panel.Panel` &amp;amp;#8211; a container of grids which delivers to user a bunch of aylook objects which are present in that specific aylook system. Objects like: cameras, alarms, diagnostics, inputs, outputs and system buttons and so on.
*   MapContainer `Ext.container.Container` &amp;amp;#8211; as the name says it&amp;amp;#8217;s a container for the current loaded aylook map.
*   StatusBar `Ext.ux.StatusBar` &amp;amp;#8211; it&amp;amp;#8217;s the bottom bar which shows mouse coordinates on map and some status messages.

``` javascript app/view/AyMenu.js

Ext.define(&#39;AyMap.view.AyMenu&#39;, {

    /* Begin Definitions */
    extend: &#39;Ext.toolbar.Toolbar&#39;,
    alias: &#39;widget.aymenu&#39;,

    requires: [
        &#39;Ext.container.ButtonGroup&#39;,
        &#39;Ext.form.field.ComboBox&#39;
    ],
    /* End Definitions */

    collapsible : true,
    height : 69,
    ui : &#39;aylook&#39;,

    initComponent: function () {
        var me = this;

        Ext.apply(me, {
            items: [
                me.getMapsMenuCfg(),
                me.getClipboardMenuCfg(),
                me.getEditMenuCfg(),
                me.getInsertMenuCfg(),
                me.getToolsMenuCfg(),
                me.getSearchFieldCfg()
            ]
        });
        me.callParent(arguments);
    },

    /**
     * Returns config object for Ext.container.ButtonGroup of the Maps menu
     * @private
     */
    getMapsMenuCfg: function(){
        return {
            xtype: &#39;buttongroup&#39;,
            title: localizer.get(&#39;titleMap&#39;), //&#39;Map&#39;,
            itemId: &#39;btnGpMaps&#39;,
            columns: 3,
            defaults: {
                scale: &#39;small&#39;,
                ui: &#39;aylook&#39;
            },
            defaultType: &#39;button&#39;,
            items: [{
                text: localizer.get(&#39;txtLoad&#39;), //&#39;Load&#39;
                iconCls: &#39;ay_load_icon&#39;,
                itemId: &#39;mMapsLoad&#39;,
                menuHandler: &#39;onMapLoadClick&#39;,
                scale: &#39;large&#39;,
                rowspan: 3,
                disabled: true
            },
                {
                    text: localizer.get(&#39;txtNew&#39;), //&#39;New&#39;,
                    iconCls: &#39;ay_new_icon&#39;,
                    itemId: &#39;mMapsNew&#39;,
                    menuHandler: &#39;onMapNewClick&#39;
                },{
                    text: localizer.get(&#39;txtProperties&#39;), //&#39;Properties&#39;,
                    iconCls: &#39;ay_prop32_icon&#39;,
                    itemId: &#39;mMapsProperties&#39;,
                    menuHandler: &#39;onMapPropertiesClick&#39;,
                    disabled: true,
                    rowspan: 3,
                    scale: &#39;large&#39;
                },{
                    text: localizer.get(&#39;txtDelete&#39;), //&#39;Delete&#39;,
                    iconCls: &#39;ay_delete16_icon&#39;,
                    menuHandler: &#39;onMapDeleteClick&#39;,
                    itemId: &#39;mMapsDelete&#39;,
                    disabled: true
                }
            ]
        };
    },
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If you notice in the &lt;code&gt;getMapsMenuCfg&lt;/code&gt; more exactly in buttons configurations, there is a custom property called &lt;code&gt;menuHandler&lt;/code&gt;, it&amp;#8217;s a config which keeps the name of the method to be called and is used usually to simplify and minimise the code. As you can see the menu is very big and has a lot of buttons and to use such approach was very in handy. In controller there is a global listener to buttons clicks of the &lt;code&gt;AyMenu&lt;/code&gt; which just calls the method stored in &lt;code&gt;menuHandler&lt;/code&gt; of each button:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;// in controller
 me.control({
  &#39;aymenu button&#39;:{
      click: function(button){
        this[button.menuHandler].call(this,button);
      }
   }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;``` javascript app/view/AyToolbox.js&lt;/p&gt;

&lt;p&gt;Ext.define(&amp;lsquo;AyMap.view.AyToolbox&amp;rsquo;,{&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/* Begin Definitions */

extend: &#39;Ext.panel.Panel&#39;,
alias: &#39;widget.aytoolbox&#39;,

requires: [
    &#39;Ext.layout.container.Accordion&#39;,
    &#39;AyMap.view.toolbox.Panel&#39;
],

/* End Definitions */

collapsible : true,
layout :&#39;accordion&#39;,
width : 118,
collapseMode : &#39;mini&#39;,
split : true,
ui : &#39;aylook&#39;,
title : localizer.get(&#39;titleTolbox&#39;),

initComponent: function(){

    Ext.apply(this,{
        defaultType : &#39;toolboxpanel&#39;,
        items:[{
            title: localizer.get(&#39;titleCameras&#39;),
            itemId: &#39;gridcamera&#39;,
            store: &#39;Cameras&#39;
        },{
            title: localizer.get(&#39;titleInputs&#39;),
            itemId: &#39;gridinput&#39;,
            store: &#39;Inputs&#39;
        },{
            title: localizer.get(&#39;titleOutputs&#39;),
            itemId: &#39;gridoutput&#39;,
            store:  &#39;Outputs&#39;
        },{
            title: localizer.get(&#39;titleVariables&#39;),
            itemId: &#39;gridvariable&#39;,
            store: &#39;Variables&#39;
        },{
            title: localizer.get(&#39;titleAlarms&#39;),
            itemId: &#39;gridburglar_alarms&#39;,
            store: &#39;Alarms&#39;
        }]
    });

    this.callParent(arguments);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;});&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
``` javascript app/view/MapContainer.js

Ext.define(&#39;AyMap.view.MapContainer&#39;,{

    /* Begin Definitions */

	extend: &#39;Ext.container.Container&#39;,
	alias: &#39;widget.mapcontainer&#39;,

    requires: [
        &#39;AyMap.ux.MapSurface&#39;,
        &#39;Ext.ux.layout.Center&#39;
    ],

    /* End Definitions */

	autoScroll: true,
    layout: &#39;ux.center&#39;,
    cls: &#39;ay-mapcontainer&#39;,

    getContextMenu: function(){
        if (!this.ctxMenu) {
            this.ctxMenu = Ext.create(&#39;AyMap.view.ContextMenu&#39;, {
                id: &#39;ctxMenu&#39;
            });
        }
        return this.ctxMenu;
    }
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So, that&amp;#8217;s it for the Viewport.&lt;br /&gt;
&lt;strong&gt;Conclusions&lt;/strong&gt;&lt;br /&gt;
In this part I have shown how to split application&amp;#8217;s UI in views and how to extend ExtJS components wisely. In the next part I will describe the rest of applications views and add some details about MapSurface component &amp;#8211; application&amp;#8217;s heart.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>
